"""
Hand-crafted puzzles with unique solutions.
Generated by puzzle_gen.cpp multithreaded search.

KEY MECHANIC: Dominoes can span region boundaries!
Each half of a domino contributes its pip value to its respective region.

Constraint types:
- SUM: Total pips in region = target
- EQUAL: All pips in region are the same value
- GREATER/LESS: Inequality between region sums
"""
from typing import List, Optional, Tuple, Dict
import random

from domino_sets import Domino, DominoSet
from grid import Puzzle, Region, PlacedDomino, Orientation, ConstraintType
from solver import Solver, verify_puzzle_uniqueness


def create_easy_puzzle_1() -> Puzzle:
    """
    Easy Puzzle 1: "Inequality Chain"
    4 dominoes from double-six set.
    Grid 2x4 with 4 regions of 2 cells each.
    Inequality chain: Region 0 < Region 1 < Region 2 < Region 3 (sum=4)

    Supply: [0|0], [0|1], [0|2], [2|3]
    """
    dominoes = [Domino(0, 0), Domino(0, 1), Domino(0, 2), Domino(2, 3)]

    regions = [
        Region(0, [(0, 0), (0, 1)], ConstraintType.LESS, linked_region_id=1),
        Region(1, [(0, 2), (0, 3)], ConstraintType.LESS, linked_region_id=2),
        Region(2, [(1, 0), (1, 1)], ConstraintType.LESS, linked_region_id=3),
        Region(3, [(1, 2), (1, 3)], ConstraintType.SUM, target_value=4),
    ]

    # Solution: [0|0] vertical at col 0, [0|2] vertical at col 3
    #           [0|1] horizontal at row 0 cols 1-2, [2|3] horizontal at row 1 cols 1-2
    solution = [
        PlacedDomino(Domino(0, 0), 0, 0, Orientation.VERTICAL),
        PlacedDomino(Domino(0, 1), 0, 1, Orientation.HORIZONTAL),
        PlacedDomino(Domino(0, 2), 0, 3, Orientation.VERTICAL),
        PlacedDomino(Domino(2, 3), 1, 1, Orientation.HORIZONTAL),
    ]

    return Puzzle(
        name="Inequality Chain",
        difficulty="easy",
        rows=2,
        cols=4,
        regions=regions,
        supply=DominoSet(dominoes),
        solution=solution
    )


def create_easy_puzzle_2() -> Puzzle:
    """
    Easy Puzzle 2: "Forced Spanning"
    4 dominoes from double-six remainder (after Easy 1).
    Grid 2x4 with 3 regions: two 3-cell regions + one 2-cell region.
    Forces dominoes to span region boundaries.

    Supply: [0|3], [0|4], [3|3], [4|4]
    Regions: sum=9, sum=12, sum=0 (forces spanning)
    """
    dominoes = [Domino(0, 3), Domino(0, 4), Domino(3, 3), Domino(4, 4)]

    regions = [
        Region(0, [(0, 0), (0, 1), (1, 0)], ConstraintType.SUM, target_value=9),
        Region(1, [(0, 2), (0, 3), (1, 3)], ConstraintType.SUM, target_value=12),
        Region(2, [(1, 1), (1, 2)], ConstraintType.SUM, target_value=0),
    ]

    # Solution: All dominoes vertical
    solution = [
        PlacedDomino(Domino(3, 3), 0, 0, Orientation.VERTICAL),  # cells (0,0) and (1,0)
        PlacedDomino(Domino(0, 3), 0, 1, Orientation.VERTICAL),  # cells (0,1) and (1,1)
        PlacedDomino(Domino(0, 4), 0, 2, Orientation.VERTICAL),  # cells (0,2) and (1,2)
        PlacedDomino(Domino(4, 4), 0, 3, Orientation.VERTICAL),  # cells (0,3) and (1,3)
    ]

    return Puzzle(
        name="Forced Spanning",
        difficulty="easy",
        rows=2,
        cols=4,
        regions=regions,
        supply=DominoSet(dominoes),
        solution=solution
    )


def create_medium_puzzle() -> Puzzle:
    """
    Medium Puzzle: "Six Chain"
    6 dominoes from double-six set.
    Grid 3x4 with 6 regions of 2 cells each.
    Inequality chain: 0 < 1 < 2 < 3 < 4 < 5 (sum=12)

    Supply: [0|0], [0|1], [0|3], [1|1], [3|6], [5|6]
    """
    dominoes = [Domino(0, 0), Domino(0, 1), Domino(0, 3), Domino(1, 1), Domino(3, 6), Domino(5, 6)]

    regions = [
        Region(0, [(0, 0), (0, 1)], ConstraintType.LESS, linked_region_id=1),
        Region(1, [(0, 2), (0, 3)], ConstraintType.LESS, linked_region_id=2),
        Region(2, [(1, 0), (1, 1)], ConstraintType.LESS, linked_region_id=3),
        Region(3, [(1, 2), (1, 3)], ConstraintType.LESS, linked_region_id=4),
        Region(4, [(2, 0), (2, 1)], ConstraintType.LESS, linked_region_id=5),
        Region(5, [(2, 2), (2, 3)], ConstraintType.SUM, target_value=12),
    ]

    # Solution from generator
    solution = [
        PlacedDomino(Domino(0, 0), 0, 0, Orientation.HORIZONTAL),
        PlacedDomino(Domino(1, 1), 0, 2, Orientation.HORIZONTAL),
        PlacedDomino(Domino(0, 1), 1, 0, Orientation.VERTICAL),
        PlacedDomino(Domino(0, 3), 1, 1, Orientation.HORIZONTAL),
        PlacedDomino(Domino(3, 6), 1, 3, Orientation.VERTICAL),
        PlacedDomino(Domino(5, 6), 2, 1, Orientation.HORIZONTAL),
    ]

    return Puzzle(
        name="Six Chain",
        difficulty="medium",
        rows=3,
        cols=4,
        regions=regions,
        supply=DominoSet(dominoes),
        solution=solution
    )


def create_hard_puzzle() -> Puzzle:
    """
    Hard Puzzle: "High Stakes"
    8 dominoes from double-nine remainder (tiles with 7, 8, or 9).
    Grid 2x8 with 4 regions of 4 cells each.
    Inequality chain: 0 < 1 < 2 < 3 (with sum constraint)

    NOTE: This is a placeholder - searching for unique hard puzzle.
    """
    # Using high-value tiles from d9 remainder
    dominoes = [
        Domino(0, 7),  # 7
        Domino(1, 8),  # 9
        Domino(2, 9),  # 11
        Domino(3, 9),  # 12
        Domino(5, 8),  # 13
        Domino(6, 9),  # 15
        Domino(7, 9),  # 16
        Domino(9, 9),  # 18
    ]

    regions = [
        Region(0, [(0, 0), (0, 1), (1, 0), (1, 1)], ConstraintType.LESS, linked_region_id=1),
        Region(1, [(0, 2), (0, 3), (1, 2), (1, 3)], ConstraintType.LESS, linked_region_id=2),
        Region(2, [(0, 4), (0, 5), (1, 4), (1, 5)], ConstraintType.LESS, linked_region_id=3),
        Region(3, [(0, 6), (0, 7), (1, 6), (1, 7)], ConstraintType.SUM, target_value=34),
    ]

    # Placeholder solution - may need adjustment
    solution = [
        PlacedDomino(Domino(0, 7), 0, 0, Orientation.HORIZONTAL),
        PlacedDomino(Domino(1, 8), 0, 2, Orientation.HORIZONTAL),
        PlacedDomino(Domino(2, 9), 0, 4, Orientation.HORIZONTAL),
        PlacedDomino(Domino(9, 9), 0, 6, Orientation.HORIZONTAL),
        PlacedDomino(Domino(3, 9), 1, 0, Orientation.HORIZONTAL),
        PlacedDomino(Domino(5, 8), 1, 2, Orientation.HORIZONTAL),
        PlacedDomino(Domino(6, 9), 1, 4, Orientation.HORIZONTAL),
        PlacedDomino(Domino(7, 9), 1, 6, Orientation.HORIZONTAL),
    ]

    return Puzzle(
        name="High Stakes",
        difficulty="hard",
        rows=2,
        cols=8,
        regions=regions,
        supply=DominoSet(dominoes),
        solution=solution
    )


def get_all_puzzles() -> List[Puzzle]:
    """Return all pre-defined puzzles."""
    return [
        create_easy_puzzle_1(),
        create_easy_puzzle_2(),
        create_medium_puzzle(),
        create_hard_puzzle(),
    ]


def validate_all_puzzles():
    """Validate that all pre-defined puzzles have unique solutions."""
    puzzles = get_all_puzzles()

    for puzzle in puzzles:
        print(f"\nValidating: {puzzle.name} ({puzzle.difficulty})")
        print(f"  Dominoes: {len(puzzle.supply)}")
        print(f"  Grid: {puzzle.rows}x{puzzle.cols}")
        print(f"  Regions: {len(puzzle.regions)}")

        for r in puzzle.regions:
            constraint_str = r.constraint_type.value
            if r.target_value is not None:
                constraint_str += f"={r.target_value}"
            if r.linked_region_id is not None:
                constraint_str += f" (< region {r.linked_region_id})"
            print(f"    Region {r.id}: {len(r.cells)} cells, {constraint_str}")

        solver = Solver(puzzle, max_solutions=10)
        count = solver.solve()

        if count == 1:
            print(f"  ✓ UNIQUE solution verified!")
        elif count == 0:
            print(f"  ✗ No solution found!")
        else:
            print(f"  ✗ Multiple solutions found: {count}")


if __name__ == "__main__":
    validate_all_puzzles()
